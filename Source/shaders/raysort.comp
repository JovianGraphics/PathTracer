#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

layout(local_size_x = 1, local_size_y = 32, local_size_z = 1) in;

#include "structures.glsl"

layout(binding = 0) uniform Constants {
    mat4 viewMtx;
    mat4 projMtx;
    mat4 viewInvMtx;
    mat4 projInvMtx;
    vec2 viewportSize;
    vec2 viewportBase;
    uint numLights;
    uint numTriangles;
    uint frameIndex;
    uint numRays;
    uint numBVHNodes;
};

layout(std430, binding = 9) buffer stackBuffer
{
    RayStackBuffer stack[];
};

layout(std430, binding = 10) buffer jobBuffer
{
    JobDesc jobGrid[];
};

void main()
{
    uint count = 0;

    uint baseIndex = gl_GlobalInvocationID.y * uint(viewportSize.x) + gl_GlobalInvocationID.x * 64;
    uint maxIndex = min(baseIndex + 64, gl_GlobalInvocationID.y * uint(viewportSize.x) + uint(viewportSize.x));

    vec3 firstDir = vec3(0.0);

    JobDesc right[64];
    uint rightCount = 0;

    for (uint x = baseIndex; x < maxIndex; x++)
    {
        if (jobGrid[x].index != 0xFFFFFFFF)
        {
            JobDesc job = jobGrid[x];
            vec3 rayDir = stack[job.index].rayDirection;

            if (count == 0)
            {
                firstDir = rayDir;
            }

            if (dot(firstDir, rayDir) > 0.0)
            {
                jobGrid[baseIndex + count] = job;
                count++;
            }
            else
            {
                right[rightCount] = job;
                rightCount++;
            }

        }
    }

    for (uint i = 0; i < rightCount; i++) jobGrid[baseIndex + count + i] = right[i];
    for (uint i = baseIndex + count + rightCount; i < maxIndex; i++) jobGrid[i].index = 0xFFFFFFFF;
}
